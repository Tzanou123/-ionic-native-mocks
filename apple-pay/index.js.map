{"version":3,"sources":["../../../src/@ionic-native-mocks/plugins/apple-pay/index.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,yBAAyB,CAAC;AACnD,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAoE7C;IAAkC,gCAAQ;IAA1C;;IAoLA,CAAC;IAnLG;;;;;;;;;;;;;;OAcG;IACH,sCAAe,GAAf;QACI,IAAI,QAAuB,CAAC;QAC5B,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,CAAC,QAAQ,CAAC,CAAC;QACtB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;;;;OAOG;IACH,gEAAyC,GAAzC;QACI,IAAI,QAAkC,CAAC;QACvC,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,UAAC,QAA4C;YAClE,QAAQ,CAAC,IAAI,CAAE,QAAQ,CAAE,CAAC;YAC1B,QAAQ,CAAC,QAAQ,EAAE,CAAC;QACxB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;OAIG;IACH,+DAAwC,GAAxC;QACI,IAAI,QAAiB,CAAC;QACtB,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,CAAC,QAAQ,CAAC,CAAC;QACtB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAkCG;IACH,oDAA6B,GAA7B,UAA8B,IAAmC;QAC7D,IAAI,QAAuC,CAAC;QAC5C,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,CAAC,QAAQ,CAAC,CAAC;QACtB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAqEG;IACH,yCAAkB,GAAlB,UAAmB,KAAa;QAC5B,IAAI,QAA0B,CAAC;QAC/B,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,CAAC,QAAQ,CAAC,CAAC;QACtB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;;;;;OAQG;IACH,8CAAuB,GAAvB,UAAwB,QAA4B;QAChD,IAAI,QAA8B,CAAC;QACnC,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,CAAC,QAAQ,CAAC,CAAC;QACtB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACN,mBAAC;AAAD,CApLA,AAoLC,CApLiC,QAAQ,GAoLzC","file":"index.js","sourceRoot":"","sourcesContent":["import { ApplePay } from '@ionic-native/apple-pay';\r\nimport { Observable } from 'rxjs/Observable';\r\nimport { Observer } from 'rxjs/Observer';\r\n\r\nexport declare type IMakePayments = 'This device can make payments and has a supported card' | 'This device cannot make payments.' | 'This device can make payments but has no supported cards';\r\nexport declare type IShippingType = 'shipping' | 'delivery' | 'store' | 'service';\r\nexport declare type IBillingRequirement = 'none' | 'all' | 'postcode' | 'name' | 'email' | 'phone';\r\nexport declare type ITransactionStatus = 'success' | 'failure' | 'invalid-billing-address' | 'invalid-shipping-address' | 'invalid-shipping-contact' | 'require-pin' | 'incorrect-pin' | 'locked-pin';\r\nexport declare type ICompleteTransaction = 'Payment status applied.';\r\nexport declare type IUpdateItemsAndShippingStatus = 'Updated List Info' | 'Did you make a payment request?';\r\nexport interface IPaymentResponse {\r\n    billingNameFirst?: string;\r\n    billingNameMiddle?: string;\r\n    billingNameLast?: string;\r\n    billingEmailAddress?: string;\r\n    billingSupplementarySubLocality?: string;\r\n    billingAddressStreet?: string;\r\n    billingAddressCity?: string;\r\n    billingAddressState?: string;\r\n    billingPostalCode?: string;\r\n    billingCountry?: string;\r\n    billingISOCountryCode?: string;\r\n    shippingNameFirst?: string;\r\n    shippingNameMiddle?: string;\r\n    shippingNameLast?: string;\r\n    shippingEmailAddress?: string;\r\n    shippingPhoneNumber?: string;\r\n    shippingSupplementarySubLocality?: string;\r\n    shippingAddressStreet?: string;\r\n    shippingAddressCity?: string;\r\n    shippingAddressState?: string;\r\n    shippingPostalCode?: string;\r\n    shippingCountry?: string;\r\n    shippingISOCountryCode?: string;\r\n    paymentData: string;\r\n    transactionIdentifier: string;\r\n    paymentMethodDisplayName?: string;\r\n    paymentMethodNetwork?: string;\r\n    paymentMethodTypeCard?: string;\r\n}\r\nexport interface IOrderItem {\r\n    label: string;\r\n    amount: number;\r\n}\r\nexport interface IShippingMethod {\r\n    identifier: string;\r\n    label: string;\r\n    detail: string;\r\n    amount: number;\r\n}\r\nexport interface IOrderItemsAndShippingMethods {\r\n    items: IOrderItem[];\r\n    shippingMethods?: IShippingMethod[];\r\n}\r\nexport interface IOrder extends IOrderItemsAndShippingMethods {\r\n    merchantIdentifier: string;\r\n    currencyCode: string;\r\n    countryCode: string;\r\n    billingAddressRequirement?: IBillingRequirement | IBillingRequirement[];\r\n    shippingAddressRequirement?: IBillingRequirement | IBillingRequirement[];\r\n    shippingType?: IShippingType;\r\n}\r\nexport interface ISelectedShippingContact {\r\n    shippingAddressCity: string;\r\n    shippingAddressState: string;\r\n    shippingPostalCode: string;\r\n    shippingISOCountryCode: string;\r\n}\r\n\r\nexport class ApplePayMock extends ApplePay {\r\n    /**\r\n     * Detects if the current device supports Apple Pay and has any capable cards registered.\r\n     * @return {Promise<IMakePayments>} Returns a promise\r\n     *\r\n     * @usage\r\n     * try {\r\n     *   const message = await this.applePay.canMakePayments();\r\n     *   // Apple Pay is enabled and a supported card is setup. Expect:\r\n     *   // 'This device can make payments and has a supported card'\r\n     * } catch (message) {\r\n     *   // There is an issue, examine the message to see the details, will be:\r\n     *   // 'This device cannot make payments.''\r\n     *   // 'This device can make payments but has no supported cards'\r\n     * }\r\n     */\r\n    canMakePayments(): Promise<IMakePayments> {\r\n        let response: IMakePayments;\r\n        return new Promise((resolve, reject) => {\r\n            resolve(response);\r\n        });\r\n    };\r\n    /**\r\n     * Starts listening for shipping contact selection changes\r\n     * Any time the user selects shipping contact, this callback will fire.\r\n     * You *must* call `updateItemsAndShippingMethods` in response or else the\r\n     * user will not be able to process payment.\r\n     * @return {Observable<ISelectedShippingContact>} emits with shipping contact information on\r\n     *   shipping contact selection changes\r\n     */\r\n    startListeningForShippingContactSelection(): Observable<ISelectedShippingContact> {\r\n        let response: ISelectedShippingContact;\r\n        return Observable.create((observer: Observer<ISelectedShippingContact>) => {\r\n            observer.next( response );\r\n            observer.complete();\r\n        });\r\n    };\r\n    /**\r\n     * Stops listening for shipping contact selection changes\r\n     * @return {Promise} whether stop listening was successful. This should\r\n     *   really only fail if this is called without starting listening\r\n     */\r\n    stopListeningForShippingContactSelection(): Promise<boolean> {\r\n        let response: boolean;\r\n        return new Promise((resolve, reject) => {\r\n            resolve(response);\r\n        });\r\n    };\r\n    /**\r\n     * Update the list of pay sheet items and shipping methods in response to\r\n     * a shipping contact selection event. This *must* be called in response to\r\n     * any shipping contact selection event or else the user will not be able\r\n     * to complete a transaction on the pay sheet. Do not call without\r\n     * subscribing to shipping contact selection events first\r\n     * @returns {Promise}\r\n     *\r\n     * @param {Object} including `items` and `shippingMethods` properties.\r\n     *\r\n     * @usage\r\n     * this.applePay.startListeningForShippingContactSelection().pluck('shippingAddressState').subscribe(shippingAddressState => {\r\n     *   let shippingMethods;\r\n     *   if ('AK' === shippingAddressState) {\r\n     *     shippingMethods = [{\r\n     *         identifier: 'Alaska',\r\n     *         label: 'Alaska',\r\n     *         detail: 'For shipping to Alaska',\r\n     *         amount: 9.99\r\n     *     },];\r\n     *   } else {\r\n     *     shippingMethods = [{\r\n     *         identifier: 'Continental',\r\n     *         label: 'Continental',\r\n     *         detail: 'For shipping Continentally',\r\n     *         amount: 5.99\r\n     *     }];\r\n     *   }\r\n     *   this.paySheetItems.shippingCost = {\r\n     *      label: 'Shipping Cost',\r\n     *      amount: shippingMethod[0].amount\r\n     *   };\r\n     *   this.applePay.updateItemsAndShippingMethods(this.paySheetItems, shippingMethods);\r\n     * });\r\n     */\r\n    updateItemsAndShippingMethods(list: IOrderItemsAndShippingMethods): Promise<IUpdateItemsAndShippingStatus> {\r\n        let response: IUpdateItemsAndShippingStatus;\r\n        return new Promise((resolve, reject) => {\r\n            resolve(response);\r\n        });\r\n    };\r\n    /**\r\n     * Request a payment with Apple Pay\r\n     * @return {Promise<IPaymentResponse>} Returns a promise that resolves when something happens\r\n     *\r\n     * @param order {IOrder}\r\n     *\r\n     * @usage\r\n     * try {\r\n     *   const paymentResponse = this.applePay.makePaymentRequest({\r\n     *     items: [\r\n     *       {\r\n     *         label: '3 x Basket Items',\r\n     *         amount: 49.99\r\n     *       },\r\n     *       {\r\n     *         label: 'Next Day Delivery',\r\n     *         amount: 3.99\r\n     *       },\r\n     *       {\r\n     *         label: 'My Fashion Company',\r\n     *         amount: 53.98\r\n     *       }\r\n     *     ],\r\n     *     shippingMethods: [\r\n     *       {\r\n     *         identifier: 'NextDay',\r\n     *         label: 'NextDay',\r\n     *         detail: 'Arrives tomorrow by 5pm.',\r\n     *         amount: 3.99\r\n     *       },\r\n     *       {\r\n     *         identifier: 'Standard',\r\n     *         label: 'Standard',\r\n     *         detail: 'Arrive by Friday.',\r\n     *         amount: 4.99\r\n     *       },\r\n     *       {\r\n     *         identifier: 'SaturdayDelivery',\r\n     *         label: 'Saturday',\r\n     *         detail: 'Arrive by 5pm this Saturday.',\r\n     *         amount: 6.99\r\n     *       }\r\n     *     ],\r\n     *     merchantIdentifier: 'merchant.apple.test',\r\n     *     currencyCode: 'GBP',\r\n     *     countryCode: 'GB',\r\n     *     billingAddressRequirement: 'none',\r\n     *     shippingAddressRequirement: 'none',\r\n     *     shippingType: 'shipping',\r\n     *   });\r\n     *\r\n     *   // The user has authorized the payment.\r\n     *\r\n     *   // Handle the token, asynchronously, i.e. pass to your merchant bank to\r\n     *   // action the payment, then once finished, depending on the outcome:\r\n     *\r\n     *   // Here is an example implementation:\r\n     *\r\n     *   const captureStatus = await MyPaymentProvider.authorizeApplePayToken(paymentResponse.paymentData);\r\n     *   await this.applePay.completeLastTransaction('success');\r\n     * }\r\n     * catch (err) {\r\n     *   if (isPaymentAuthError(err)) {\r\n     *     this.completeLastTransaction('failure');\r\n     *   }\r\n     *   else {\r\n     *     // Failed to open pay sheet or user canceled payment\r\n     *   }\r\n     * }\r\n     */\r\n    makePaymentRequest(order: IOrder): Promise<IPaymentResponse> {\r\n        let response: IPaymentResponse;\r\n        return new Promise((resolve, reject) => {\r\n            resolve(response);\r\n        });\r\n    };\r\n    /**\r\n     * Once the makePaymentRequest has been resolved successfully, the device will be waiting for a completion event.\r\n     * This means, that the application must proceed with the token authorisation and return a success, failure,\r\n     * or other validation error. Once this has been passed back, the Apple Pay sheet will be dismissed via an animation.\r\n     * @return {Promise<ICompleteTransaction>} Returns a promise that resolves after confirmation of payment authorization completion\r\n     *\r\n     * @param complete {ITransactionStatus}\r\n     *\r\n     */\r\n    completeLastTransaction(complete: ITransactionStatus): Promise<ICompleteTransaction> {\r\n        let response: ICompleteTransaction;\r\n        return new Promise((resolve, reject) => {\r\n            resolve(response);\r\n        });\r\n    };\r\n}\r\n"]}